{"version":3,"file":"4365.945362f1422adbdc8c39.entry.js","mappings":"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","sources":["webpack://superset/./node_modules/dom-helpers/util/inDOM.js","webpack://superset/./node_modules/dom-helpers/util/scrollbarSize.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/utils/maxElementSize.js","webpack://superset/./node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js","webpack://superset/./node_modules/react-virtualized/dist/es/utils/animationFrame.js","webpack://superset/./node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/Grid.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js","webpack://superset/./node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _default = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = scrollbarSize;\n\nvar _inDOM = _interopRequireDefault(require(\"./inDOM\"));\n\nvar size;\n\nfunction scrollbarSize(recalc) {\n  if (!size && size !== 0 || recalc) {\n    if (_inDOM.default) {\n      var scrollDiv = document.createElement('div');\n      scrollDiv.style.position = 'absolute';\n      scrollDiv.style.top = '-9999px';\n      scrollDiv.style.width = '50px';\n      scrollDiv.style.height = '50px';\n      scrollDiv.style.overflow = 'scroll';\n      document.body.appendChild(scrollDiv);\n      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n    }\n  }\n\n  return size;\n}\n\nmodule.exports = exports[\"default\"];","\n\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps);\n\n    // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}\n\n/**\n * Helper method that determines when to recalculate row or column metadata.\n */","import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nvar CellSizeAndPositionManager = function () {\n\n  // Used in deferred mode to track which cells have been queued for measurement.\n\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  function CellSizeAndPositionManager(_ref) {\n    var cellCount = _ref.cellCount,\n        cellSizeGetter = _ref.cellSizeGetter,\n        estimatedCellSize = _ref.estimatedCellSize;\n\n    _classCallCheck(this, CellSizeAndPositionManager);\n\n    this._cellSizeAndPositionData = {};\n    this._lastMeasuredIndex = -1;\n    this._lastBatchedIndex = -1;\n\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n  }\n\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n\n\n  _createClass(CellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return false;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(_ref2) {\n      var cellCount = _ref2.cellCount,\n          estimatedCellSize = _ref2.estimatedCellSize,\n          cellSizeGetter = _ref2.cellSizeGetter;\n\n      this._cellCount = cellCount;\n      this._estimatedCellSize = estimatedCellSize;\n      this._cellSizeGetter = cellSizeGetter;\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellCount;\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._estimatedCellSize;\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._lastMeasuredIndex;\n    }\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment() {\n      return 0;\n    }\n\n    /**\n     * This method returns the size and position for the cell at the specified index.\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\n     */\n\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      if (index < 0 || index >= this._cellCount) {\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\n      }\n\n      if (index > this._lastMeasuredIndex) {\n        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n\n        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n          var _size = this._cellSizeGetter({ index: i });\n\n          // undefined or NaN probably means a logic error in the size getter.\n          // null means we're using CellMeasurer and haven't yet measured a given index.\n          if (_size === undefined || isNaN(_size)) {\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\n          } else if (_size === null) {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: 0\n            };\n\n            this._lastBatchedIndex = index;\n          } else {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: _size\n            };\n\n            _offset += _size;\n\n            this._lastMeasuredIndex = index;\n          }\n        }\n      }\n\n      return this._cellSizeAndPositionData[index];\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    /**\n     * Total size of all cells being measured.\n     * This value will be completely estimated initially.\n     * As cells are measured, the estimate will be updated.\n     */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\n      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;\n      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\n    }\n\n    /**\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\n     * If the cell is already visible then the current offset will be returned.\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n     *\n     * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @param currentOffset Container's current (x or y) offset\n     * @param totalSize Total size (width or height) of all cells\n     * @return Offset to use to ensure the specified cell is visible\n     */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      if (containerSize <= 0) {\n        return 0;\n      }\n\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\n      var maxOffset = datum.offset;\n      var minOffset = maxOffset - containerSize + datum.size;\n\n      var idealOffset = void 0;\n\n      switch (align) {\n        case 'start':\n          idealOffset = maxOffset;\n          break;\n        case 'end':\n          idealOffset = minOffset;\n          break;\n        case 'center':\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\n          break;\n        default:\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n          break;\n      }\n\n      var totalSize = this.getTotalSize();\n\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    }\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(params) {\n      var containerSize = params.containerSize,\n          offset = params.offset;\n\n\n      var totalSize = this.getTotalSize();\n\n      if (totalSize === 0) {\n        return {};\n      }\n\n      var maxOffset = offset + containerSize;\n      var start = this._findNearestCell(offset);\n\n      var datum = this.getSizeAndPositionOfCell(start);\n      offset = datum.offset + datum.size;\n\n      var stop = start;\n\n      while (offset < maxOffset && stop < this._cellCount - 1) {\n        stop++;\n\n        offset += this.getSizeAndPositionOfCell(stop).size;\n      }\n\n      return {\n        start: start,\n        stop: stop\n      };\n    }\n\n    /**\n     * Clear all cached values for cells after the specified index.\n     * This method should be called for any cell that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n     */\n\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n    }\n  }, {\n    key: '_binarySearch',\n    value: function _binarySearch(high, low, offset) {\n      while (low <= high) {\n        var middle = low + Math.floor((high - low) / 2);\n        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;\n\n        if (_currentOffset === offset) {\n          return middle;\n        } else if (_currentOffset < offset) {\n          low = middle + 1;\n        } else if (_currentOffset > offset) {\n          high = middle - 1;\n        }\n      }\n\n      if (low > 0) {\n        return low - 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: '_exponentialSearch',\n    value: function _exponentialSearch(index, offset) {\n      var interval = 1;\n\n      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {\n        index += interval;\n        interval *= 2;\n      }\n\n      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);\n    }\n\n    /**\n     * Searches for the cell (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest cell index will be returned.\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n     */\n\n  }, {\n    key: '_findNearestCell',\n    value: function _findNearestCell(offset) {\n      if (isNaN(offset)) {\n        throw Error('Invalid offset ' + offset + ' specified');\n      }\n\n      // Our search algorithms find the nearest match at or below the specified offset.\n      // So make sure the offset is at least 0 or no match will be found.\n      offset = Math.max(0, offset);\n\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n      if (lastMeasuredCellSizeAndPosition.offset >= offset) {\n        // If we've already measured cells within this range just use a binary search as it's faster.\n        return this._binarySearch(lastMeasuredIndex, 0, offset);\n      } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return this._exponentialSearch(lastMeasuredIndex, offset);\n      }\n    }\n  }]);\n\n  return CellSizeAndPositionManager;\n}();\n\nexport default CellSizeAndPositionManager;\nimport { bpfrpt_proptype_Alignment } from '../types';\nimport { bpfrpt_proptype_CellSizeGetter } from '../types';\nimport { bpfrpt_proptype_VisibleCellRange } from '../types';","import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\n\n\nimport CellSizeAndPositionManager from './CellSizeAndPositionManager';\n\nimport { getMaxElementSize } from './maxElementSize.js';\n\n/**\n * Browsers have scroll offset limitations (eg Chrome stops scrolling at ~33.5M pixels where as Edge tops out at ~1.5M pixels).\n * After a certain position, the browser won't allow the user to scroll further (even via JavaScript scroll offset adjustments).\n * This util picks a lower ceiling for max size and artificially adjusts positions within to make it transparent for users.\n */\n\n/**\n * Extends CellSizeAndPositionManager and adds scaling behavior for lists that are too large to fit within a browser's native limits.\n */\nvar ScalingCellSizeAndPositionManager = function () {\n  function ScalingCellSizeAndPositionManager(_ref) {\n    var _ref$maxScrollSize = _ref.maxScrollSize,\n        maxScrollSize = _ref$maxScrollSize === undefined ? getMaxElementSize() : _ref$maxScrollSize,\n        params = _objectWithoutProperties(_ref, ['maxScrollSize']);\n\n    _classCallCheck(this, ScalingCellSizeAndPositionManager);\n\n    // Favor composition over inheritance to simplify IE10 support\n    this._cellSizeAndPositionManager = new CellSizeAndPositionManager(params);\n    this._maxScrollSize = maxScrollSize;\n  }\n\n  _createClass(ScalingCellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(params) {\n      this._cellSizeAndPositionManager.configure(params);\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellSizeAndPositionManager.getCellCount();\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._cellSizeAndPositionManager.getEstimatedCellSize();\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._cellSizeAndPositionManager.getLastMeasuredIndex();\n    }\n\n    /**\n     * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.\n     * The offset passed to this function is scaled (safe) as well.\n     */\n\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment(_ref2) {\n      var containerSize = _ref2.containerSize,\n          offset = _ref2.offset;\n\n      var totalSize = this._cellSizeAndPositionManager.getTotalSize();\n      var safeTotalSize = this.getTotalSize();\n      var offsetPercentage = this._getOffsetPercentage({\n        containerSize: containerSize,\n        offset: offset,\n        totalSize: safeTotalSize\n      });\n\n      return Math.round(offsetPercentage * (safeTotalSize - totalSize));\n    }\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();\n    }\n\n    /** See CellSizeAndPositionManager#getTotalSize */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());\n    }\n\n    /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      currentOffset = this._safeOffsetToOffset({\n        containerSize: containerSize,\n        offset: currentOffset\n      });\n\n      var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({\n        align: align,\n        containerSize: containerSize,\n        currentOffset: currentOffset,\n        targetIndex: targetIndex\n      });\n\n      return this._offsetToSafeOffset({\n        containerSize: containerSize,\n        offset: offset\n      });\n    }\n\n    /** See CellSizeAndPositionManager#getVisibleCellRange */\n\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(_ref4) {\n      var containerSize = _ref4.containerSize,\n          offset = _ref4.offset;\n\n      offset = this._safeOffsetToOffset({\n        containerSize: containerSize,\n        offset: offset\n      });\n\n      return this._cellSizeAndPositionManager.getVisibleCellRange({\n        containerSize: containerSize,\n        offset: offset\n      });\n    }\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._cellSizeAndPositionManager.resetCell(index);\n    }\n  }, {\n    key: '_getOffsetPercentage',\n    value: function _getOffsetPercentage(_ref5) {\n      var containerSize = _ref5.containerSize,\n          offset = _ref5.offset,\n          totalSize = _ref5.totalSize;\n\n      return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);\n    }\n  }, {\n    key: '_offsetToSafeOffset',\n    value: function _offsetToSafeOffset(_ref6) {\n      var containerSize = _ref6.containerSize,\n          offset = _ref6.offset;\n\n      var totalSize = this._cellSizeAndPositionManager.getTotalSize();\n      var safeTotalSize = this.getTotalSize();\n\n      if (totalSize === safeTotalSize) {\n        return offset;\n      } else {\n        var offsetPercentage = this._getOffsetPercentage({\n          containerSize: containerSize,\n          offset: offset,\n          totalSize: totalSize\n        });\n\n        return Math.round(offsetPercentage * (safeTotalSize - containerSize));\n      }\n    }\n  }, {\n    key: '_safeOffsetToOffset',\n    value: function _safeOffsetToOffset(_ref7) {\n      var containerSize = _ref7.containerSize,\n          offset = _ref7.offset;\n\n      var totalSize = this._cellSizeAndPositionManager.getTotalSize();\n      var safeTotalSize = this.getTotalSize();\n\n      if (totalSize === safeTotalSize) {\n        return offset;\n      } else {\n        var offsetPercentage = this._getOffsetPercentage({\n          containerSize: containerSize,\n          offset: offset,\n          totalSize: safeTotalSize\n        });\n\n        return Math.round(offsetPercentage * (totalSize - containerSize));\n      }\n    }\n  }]);\n\n  return ScalingCellSizeAndPositionManager;\n}();\n\nexport default ScalingCellSizeAndPositionManager;\nimport { bpfrpt_proptype_Alignment } from '../types';\nimport { bpfrpt_proptype_CellSizeGetter } from '../types';\nimport { bpfrpt_proptype_VisibleCellRange } from '../types';","var DEFAULT_MAX_ELEMENT_SIZE = 1500000;\nvar CHROME_MAX_ELEMENT_SIZE = 1.67771e7;\n\nvar isBrowser = function isBrowser() {\n  return typeof window !== 'undefined';\n};\n\nvar isChrome = function isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n};\n\nexport var getMaxElementSize = function getMaxElementSize() {\n  if (isBrowser()) {\n    if (isChrome()) {\n      return CHROME_MAX_ELEMENT_SIZE;\n    }\n  }\n  return DEFAULT_MAX_ELEMENT_SIZE;\n};","import _Object$keys from 'babel-runtime/core-js/object/keys';\n/**\n * Helper utility that updates the specified callback whenever any of the specified indices have changed.\n */\nexport default function createCallbackMemoizer() {\n  var requireAllKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  var cachedIndices = {};\n\n  return function (_ref) {\n    var callback = _ref.callback,\n        indices = _ref.indices;\n\n    var keys = _Object$keys(indices);\n    var allInitialized = !requireAllKeys || keys.every(function (key) {\n      var value = indices[key];\n      return Array.isArray(value) ? value.length > 0 : value >= 0;\n    });\n    var indexChanged = keys.length !== _Object$keys(cachedIndices).length || keys.some(function (key) {\n      var cachedValue = cachedIndices[key];\n      var value = indices[key];\n\n      return Array.isArray(value) ? cachedValue.join(',') !== value.join(',') : cachedValue !== value;\n    });\n\n    cachedIndices = indices;\n\n    if (allInitialized && indexChanged) {\n      callback(indices);\n    }\n  };\n}","\n\nimport ScalingCellSizeAndPositionManager from './ScalingCellSizeAndPositionManager.js';\n\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n\nexport default function updateScrollIndexHelper(_ref) {\n  var cellSize = _ref.cellSize,\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\n      previousCellsCount = _ref.previousCellsCount,\n      previousCellSize = _ref.previousCellSize,\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\n      previousScrollToIndex = _ref.previousScrollToIndex,\n      previousSize = _ref.previousSize,\n      scrollOffset = _ref.scrollOffset,\n      scrollToAlignment = _ref.scrollToAlignment,\n      scrollToIndex = _ref.scrollToIndex,\n      size = _ref.size,\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\n\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\n\n  // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex);\n\n    // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}\nimport { bpfrpt_proptype_Alignment } from '../types';\nimport { bpfrpt_proptype_CellSize } from '../types';","\n\n// Properly handle server-side rendering.\nvar win = void 0;\n\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\n\n// requestAnimationFrame() shim by Paul Irish\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\nvar request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (callback) {\n  return win.setTimeout(callback, 1000 / 60);\n};\n\nvar cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function (id) {\n  win.clearTimeout(id);\n};\n\nexport var raf = request;\nexport var caf = cancel;","import { caf, raf } from './animationFrame';\n\nvar bpfrpt_proptype_AnimationTimeoutId = process.env.NODE_ENV === 'production' ? null : {\n  id: PropTypes.number.isRequired\n};\n\n\nexport var cancelAnimationTimeout = function cancelAnimationTimeout(frame) {\n  return caf(frame.id);\n};\n\n/**\n * Recursively calls requestAnimationFrame until a specified delay has been met or exceeded.\n * When the delay time has been reached the function you're timing out will be called.\n *\n * Credit: Joe Lambert (https://gist.github.com/joelambert/1002116#file-requesttimeout-js)\n */\nexport var requestAnimationTimeout = function requestAnimationTimeout(callback, delay) {\n  var start = Date.now();\n\n  var timeout = function timeout() {\n    if (Date.now() - start >= delay) {\n      callback.call();\n    } else {\n      frame.id = raf(timeout);\n    }\n  };\n\n  var frame = {\n    id: raf(timeout)\n  };\n\n  return frame;\n};\nimport PropTypes from 'prop-types';\nexport { bpfrpt_proptype_AnimationTimeoutId };","import _Object$assign from 'babel-runtime/core-js/object/assign';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport * as React from 'react';\nimport cn from 'classnames';\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from './utils/calculateSizeAndPositionDataAndUpdateScrollOffset';\nimport ScalingCellSizeAndPositionManager from './utils/ScalingCellSizeAndPositionManager';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport defaultOverscanIndicesGetter, { SCROLL_DIRECTION_BACKWARD, SCROLL_DIRECTION_FORWARD } from './defaultOverscanIndicesGetter';\nimport updateScrollIndexHelper from './utils/updateScrollIndexHelper';\nimport defaultCellRangeRenderer from './defaultCellRangeRenderer';\nimport scrollbarSize from 'dom-helpers/util/scrollbarSize';\nimport { polyfill } from 'react-lifecycles-compat';\nimport { requestAnimationTimeout, cancelAnimationTimeout } from '../utils/requestAnimationTimeout';\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nexport var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = function (_React$PureComponent) {\n  _inherits(Grid, _React$PureComponent);\n\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\n  function Grid(props) {\n    _classCallCheck(this, Grid);\n\n    var _this = _possibleConstructorReturn(this, (Grid.__proto__ || _Object$getPrototypeOf(Grid)).call(this, props));\n\n    _this._onGridRenderedMemoizer = createCallbackMemoizer();\n    _this._onScrollMemoizer = createCallbackMemoizer(false);\n    _this._deferredInvalidateColumnIndex = null;\n    _this._deferredInvalidateRowIndex = null;\n    _this._recomputeScrollLeftFlag = false;\n    _this._recomputeScrollTopFlag = false;\n    _this._horizontalScrollBarSize = 0;\n    _this._verticalScrollBarSize = 0;\n    _this._scrollbarPresenceChanged = false;\n    _this._renderedColumnStartIndex = 0;\n    _this._renderedColumnStopIndex = 0;\n    _this._renderedRowStartIndex = 0;\n    _this._renderedRowStopIndex = 0;\n    _this._styleCache = {};\n    _this._cellCache = {};\n\n    _this._debounceScrollEndedCallback = function () {\n      _this._disablePointerEventsTimeoutId = null;\n      // isScrolling is used to determine if we reset styleCache\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    };\n\n    _this._invokeOnGridRenderedHelper = function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    };\n\n    var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n    return _this;\n  }\n\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  _createClass(Grid, [{\n    key: 'getOffsetForCell',\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = _extends({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: 'getTotalRowsHeight',\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: 'getTotalColumnsWidth',\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: 'handleScrollEvent',\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop;\n\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      this._debounceScrollEnded();\n\n      var _props = this.props,\n          autoHeight = _props.autoHeight,\n          autoWidth = _props.autoWidth,\n          height = _props.height,\n          width = _props.width;\n      var instanceProps = this.state.instanceProps;\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: _scrollDirectionHorizontal,\n          scrollDirectionVertical: _scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: 'invalidateCellSizeAfterRender',\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: 'measureAllCells',\n    value: function measureAllCells() {\n      var _props2 = this.props,\n          columnCount = _props2.columnCount,\n          rowCount = _props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: 'recomputeGridSize',\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;\n\n      var _props3 = this.props,\n          scrollToColumn = _props3.scrollToColumn,\n          scrollToRow = _props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n\n\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\n\n      // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && columnIndex <= scrollToColumn;\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && rowIndex <= scrollToRow;\n\n      // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n      this._styleCache = {};\n      this._cellCache = {};\n\n      this.forceUpdate();\n    }\n\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: 'scrollToCell',\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n\n\n      var props = this.props;\n\n      // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_extends({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_extends({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props4 = this.props,\n          getScrollbarSize = _props4.getScrollbarSize,\n          height = _props4.height,\n          scrollLeft = _props4.scrollLeft,\n          scrollToColumn = _props4.scrollToColumn,\n          scrollTop = _props4.scrollTop,\n          scrollToRow = _props4.scrollToRow,\n          width = _props4.width;\n      var instanceProps = this.state.instanceProps;\n\n      // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0;\n\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          prevState.instanceProps.scrollbarSize = getScrollbarSize();\n          prevState.instanceProps.scrollbarSizeMeasured = true;\n          prevState.needToResetStyleCache = false;\n          return prevState;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        this.setState(function (prevState) {\n          var stateUpdate = Grid._getScrollToPositionStateUpdate({\n            prevState: prevState,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop\n          });\n          if (stateUpdate) {\n            stateUpdate.needToResetStyleCache = false;\n            return stateUpdate;\n          }\n          return null;\n        });\n      }\n\n      // setting the ref's scrollLeft and scrollTop.\n      // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n      if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n        this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n      }\n      if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n        this._scrollingContainer.scrollTop = this.state.scrollTop;\n      }\n\n      // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      }\n\n      // Update onRowsRendered callback\n      this._invokeOnGridRenderedHelper();\n\n      // Initialize onScroll callback\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props5 = this.props,\n          autoHeight = _props5.autoHeight,\n          autoWidth = _props5.autoWidth,\n          columnCount = _props5.columnCount,\n          height = _props5.height,\n          rowCount = _props5.rowCount,\n          scrollToAlignment = _props5.scrollToAlignment,\n          scrollToColumn = _props5.scrollToColumn,\n          scrollToRow = _props5.scrollToRow,\n          width = _props5.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop,\n          instanceProps = _state.instanceProps;\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize();\n\n      // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;\n\n      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnGridRenderedHelper();\n\n      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n          autoContainerWidth = _props6.autoContainerWidth,\n          autoHeight = _props6.autoHeight,\n          autoWidth = _props6.autoWidth,\n          className = _props6.className,\n          containerProps = _props6.containerProps,\n          containerRole = _props6.containerRole,\n          containerStyle = _props6.containerStyle,\n          height = _props6.height,\n          id = _props6.id,\n          noContentRenderer = _props6.noContentRenderer,\n          role = _props6.role,\n          style = _props6.style,\n          tabIndex = _props6.tabIndex,\n          width = _props6.width;\n      var _state2 = this.state,\n          instanceProps = _state2.instanceProps,\n          needToResetStyleCache = _state2.needToResetStyleCache;\n\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      }\n\n      // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      }\n\n      // calculate children to render here\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      }\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n\n      var childrenToDisplay = this._childrenToDisplay;\n\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n\n      return React.createElement(\n        'div',\n        _extends({\n          ref: this._setScrollingContainerRef\n        }, containerProps, {\n          'aria-label': this.props['aria-label'],\n          'aria-readonly': this.props['aria-readonly'],\n          className: cn('ReactVirtualized__Grid', className),\n          id: id,\n          onScroll: this._onScroll,\n          role: role,\n          style: _extends({}, gridStyle, style),\n          tabIndex: tabIndex }),\n        childrenToDisplay.length > 0 && React.createElement(\n          'div',\n          {\n            className: 'ReactVirtualized__Grid__innerScrollContainer',\n            role: containerRole,\n            style: _extends({\n              width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n              height: totalRowsHeight,\n              maxWidth: totalColumnsWidth,\n              maxHeight: totalRowsHeight,\n              overflow: 'hidden',\n              pointerEvents: isScrolling ? 'none' : '',\n              position: 'relative'\n            }, containerStyle) },\n          childrenToDisplay\n        ),\n        showNoContentRenderer && noContentRenderer()\n      );\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: '_calculateChildrenToRender',\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n\n\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = [];\n\n      // Render only enough columns and rows to cover the visible area of the grid.\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex;\n\n        // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          }\n\n          // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        });\n\n        // update the indices\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_debounceScrollEnded',\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: '_handleInvalidatedGridSize',\n\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n\n        this.recomputeGridSize({ columnIndex: columnIndex, rowIndex: rowIndex });\n      }\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _props7 = _this3.props,\n              height = _props7.height,\n              onScroll = _props7.onScroll,\n              width = _props7.width;\n\n\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_isScrolling',\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: '_maybeCallOnScrollbarPresenceChange',\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n\n\n        this._scrollbarPresenceChanged = false;\n\n        _onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: 'scrollToPosition',\n\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      this.setState(function (prevState) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          return stateUpdate;\n        }\n        return null;\n      });\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: '_updateScrollLeftForScrollToColumn',\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n      }\n      this.setState(stateUpdate);\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: '_resetStyleCache',\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n\n      // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      this._cellCache = {};\n      this._styleCache = {};\n\n      // Copy over the visible cell styles so avoid unnecessary re-render.\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = rowIndex + '-' + columnIndex;\n          this._styleCache[key] = styleCache[key];\n        }\n      }\n    }\n  }, {\n    key: '_updateScrollTopForScrollToRow',\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n      }\n      this.setState(stateUpdate);\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0;\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        // this handles the weird edge case where setting scrollToColumn in\n        // multigrid was causing multiple getDerivedStateFromProps calls. Overriding\n        // the state set in the first time.\n        // We should warn since if scrollTo{column,row} and scroll{left,top} is specified,\n        // scrollTo{column,row} should override.\n        if (nextProps.scrollToColumn > 0 && prevState.scrollLeft && nextProps.scrollLeft === 0) {\n          //NOOP\n        } else if (nextProps.scrollToRow > 0 && prevState.scrollTop && nextProps.scrollTop === 0) {\n          //NOOP\n        } else {\n          _Object$assign(newState, Grid._getScrollToPositionStateUpdate({\n            prevState: prevState,\n            scrollLeft: nextProps.scrollLeft,\n            scrollTop: nextProps.scrollTop\n          }));\n        }\n      }\n\n      var instanceProps = prevState.instanceProps;\n\n      // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      }\n\n      // If scrolling is controlled outside this component, clear cache when scrolling stops\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        _Object$assign(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA = void 0;\n      var maybeStateB = void 0;\n\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\n\n      // getting scrollBarSize (moved from componentWillMount)\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n\n      return _extends({}, newState, maybeStateA, maybeStateB);\n    }\n  }, {\n    key: '_getEstimatedColumnSize',\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: '_getEstimatedRowSize',\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: '_getScrollToPositionStateUpdate',\n\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n      return null;\n    }\n  }, {\n    key: '_wrapSizeGetter',\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: '_getScrollLeftForScrollToColumnStateUpdate',\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n      return null;\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: '_getScrollTopForScrollToRowStateUpdate',\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n      return null;\n    }\n  }]);\n\n  return Grid;\n}(React.PureComponent);\n\nGrid.defaultProps = {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: defaultCellRangeRenderer,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: scrollbarSize,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: defaultOverscanIndicesGetter,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0\n};\nGrid.propTypes = process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": PropTypes.string.isRequired,\n  \"aria-readonly\": PropTypes.bool,\n\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  autoContainerWidth: PropTypes.bool.isRequired,\n\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool.isRequired,\n\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoWidth: PropTypes.bool.isRequired,\n\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  cellRenderer: function cellRenderer() {\n    return (typeof bpfrpt_proptype_CellRenderer === 'function' ? bpfrpt_proptype_CellRenderer.isRequired ? bpfrpt_proptype_CellRenderer.isRequired : bpfrpt_proptype_CellRenderer : PropTypes.shape(bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  cellRangeRenderer: function cellRangeRenderer() {\n    return (typeof bpfrpt_proptype_CellRangeRenderer === 'function' ? bpfrpt_proptype_CellRangeRenderer.isRequired ? bpfrpt_proptype_CellRangeRenderer.isRequired : bpfrpt_proptype_CellRangeRenderer : PropTypes.shape(bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  className: PropTypes.string,\n\n\n  /** Number of columns in grid.  */\n  columnCount: PropTypes.number.isRequired,\n\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  columnWidth: function columnWidth() {\n    return (typeof bpfrpt_proptype_CellSize === 'function' ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n\n  /** Unfiltered props for the Grid container. */\n  containerProps: PropTypes.object,\n\n\n  /** ARIA role for the cell-container.  */\n  containerRole: PropTypes.string.isRequired,\n\n\n  /** Optional inline style applied to inner cell-container */\n  containerStyle: PropTypes.object.isRequired,\n\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  deferredMeasurementCache: PropTypes.object,\n\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  estimatedColumnSize: PropTypes.number.isRequired,\n\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  estimatedRowSize: PropTypes.number.isRequired,\n\n\n  /** Exposed for testing purposes only.  */\n  getScrollbarSize: PropTypes.func.isRequired,\n\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  height: PropTypes.number.isRequired,\n\n\n  /** Optional custom id to attach to root Grid element.  */\n  id: PropTypes.string,\n\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  isScrolling: PropTypes.bool,\n\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  noContentRenderer: function noContentRenderer() {\n    return (typeof bpfrpt_proptype_NoContentRenderer === 'function' ? bpfrpt_proptype_NoContentRenderer.isRequired ? bpfrpt_proptype_NoContentRenderer.isRequired : bpfrpt_proptype_NoContentRenderer : PropTypes.shape(bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  onScroll: PropTypes.func.isRequired,\n\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  onScrollbarPresenceChange: PropTypes.func.isRequired,\n\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  onSectionRendered: PropTypes.func.isRequired,\n\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanColumnCount: PropTypes.number.isRequired,\n\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  overscanIndicesGetter: function overscanIndicesGetter() {\n    return (typeof bpfrpt_proptype_OverscanIndicesGetter === 'function' ? bpfrpt_proptype_OverscanIndicesGetter.isRequired ? bpfrpt_proptype_OverscanIndicesGetter.isRequired : bpfrpt_proptype_OverscanIndicesGetter : PropTypes.shape(bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanRowCount: PropTypes.number.isRequired,\n\n\n  /** ARIA role for the grid element.  */\n  role: PropTypes.string.isRequired,\n\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  rowHeight: function rowHeight() {\n    return (typeof bpfrpt_proptype_CellSize === 'function' ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n\n  /** Number of rows in grid.  */\n  rowCount: PropTypes.number.isRequired,\n\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  scrollingResetTimeInterval: PropTypes.number.isRequired,\n\n\n  /** Horizontal offset. */\n  scrollLeft: PropTypes.number,\n\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: function scrollToAlignment() {\n    return (typeof bpfrpt_proptype_Alignment === 'function' ? bpfrpt_proptype_Alignment.isRequired ? bpfrpt_proptype_Alignment.isRequired : bpfrpt_proptype_Alignment : PropTypes.shape(bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToColumn: PropTypes.number.isRequired,\n\n\n  /** Vertical offset. */\n  scrollTop: PropTypes.number,\n\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToRow: PropTypes.number.isRequired,\n\n\n  /** Optional inline style */\n  style: PropTypes.object.isRequired,\n\n\n  /** Tab index for focus */\n  tabIndex: PropTypes.number,\n\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  width: PropTypes.number.isRequired\n};\n\n\npolyfill(Grid);\nexport default Grid;\nimport { bpfrpt_proptype_CellRenderer } from './types';\nimport { bpfrpt_proptype_CellRangeRenderer } from './types';\nimport { bpfrpt_proptype_CellPosition } from './types';\nimport { bpfrpt_proptype_CellSize } from './types';\nimport { bpfrpt_proptype_CellSizeGetter } from './types';\nimport { bpfrpt_proptype_NoContentRenderer } from './types';\nimport { bpfrpt_proptype_Scroll } from './types';\nimport { bpfrpt_proptype_ScrollbarPresenceChange } from './types';\nimport { bpfrpt_proptype_RenderedSection } from './types';\nimport { bpfrpt_proptype_OverscanIndicesGetter } from './types';\nimport { bpfrpt_proptype_Alignment } from './types';\nimport { bpfrpt_proptype_CellCache } from './types';\nimport { bpfrpt_proptype_StyleCache } from './types';\nimport { bpfrpt_proptype_AnimationTimeoutId } from '../utils/requestAnimationTimeout';\nimport PropTypes from 'prop-types';","\n\nexport var SCROLL_DIRECTION_BACKWARD = -1;\n\nexport var SCROLL_DIRECTION_FORWARD = 1;\n\nexport var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexport var SCROLL_DIRECTION_VERTICAL = 'vertical';\n\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexport default function defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex)\n    };\n  }\n}\nimport { bpfrpt_proptype_OverscanIndicesGetterParams } from './types';\nimport { bpfrpt_proptype_OverscanIndices } from './types';","\n\n/**\n * Default implementation of cellRangeRenderer used by Grid.\n * This renderer supports cell-caching while the user is scrolling.\n */\n\nexport default function defaultCellRangeRenderer(_ref) {\n  var cellCache = _ref.cellCache,\n      cellRenderer = _ref.cellRenderer,\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\n      columnStartIndex = _ref.columnStartIndex,\n      columnStopIndex = _ref.columnStopIndex,\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\n      isScrolling = _ref.isScrolling,\n      parent = _ref.parent,\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\n      rowStartIndex = _ref.rowStartIndex,\n      rowStopIndex = _ref.rowStopIndex,\n      styleCache = _ref.styleCache,\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\n      visibleColumnIndices = _ref.visibleColumnIndices,\n      visibleRowIndices = _ref.visibleRowIndices;\n\n  var renderedCells = [];\n\n  // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      var key = rowIndex + '-' + columnIndex;\n      var style = void 0;\n\n      // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n\n          styleCache[key] = style;\n        }\n      }\n\n      var cellRendererParams = {\n        columnIndex: columnIndex,\n        isScrolling: isScrolling,\n        isVisible: isVisible,\n        key: key,\n        parent: parent,\n        rowIndex: rowIndex,\n        style: style\n      };\n\n      var renderedCell = void 0;\n\n      // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      if (isScrolling && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n\n        renderedCell = cellCache[key];\n\n        // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n\n      renderedCells.push(renderedCell);\n    }\n  }\n\n  return renderedCells;\n}\n\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}\nimport { bpfrpt_proptype_CellRangeRendererParams } from './types';","\n\nexport var SCROLL_DIRECTION_BACKWARD = -1;\n\nexport var SCROLL_DIRECTION_FORWARD = 1;\n\nexport var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexport var SCROLL_DIRECTION_VERTICAL = 'vertical';\n\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexport default function defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  // Make sure we render at least 1 cell extra before and after (except near boundaries)\n  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases\n  // For more info see issues #625\n  overscanCellsCount = Math.max(1, overscanCellsCount);\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - 1),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)\n    };\n  }\n}\nimport { bpfrpt_proptype_OverscanIndicesGetterParams } from './types';\nimport { bpfrpt_proptype_OverscanIndices } from './types';"],"names":["exports","__esModule","_default","window","document","createElement","module","_interopRequireDefault","recalc","size","_inDOM","default","scrollDiv","style","position","top","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","calculateSizeAndPositionDataAndUpdateScrollOffset","_ref","cellCount","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","scrollToIndex","updateScrollOffsetForScrollToIndex","CellSizeAndPositionManager","cellSizeGetter","estimatedCellSize","this","_cellSizeAndPositionData","_lastMeasuredIndex","_lastBatchedIndex","_cellSizeGetter","_cellCount","_estimatedCellSize","key","value","_ref2","index","Error","lastMeasuredCellSizeAndPosition","getSizeAndPositionOfLastMeasuredCell","_offset","offset","i","_size","undefined","isNaN","_ref3","_ref3$align","align","containerSize","currentOffset","targetIndex","datum","getSizeAndPositionOfCell","maxOffset","minOffset","idealOffset","Math","max","min","totalSize","getTotalSize","params","start","_findNearestCell","stop","high","low","middle","floor","_currentOffset","interval","_binarySearch","lastMeasuredIndex","_exponentialSearch","ScalingCellSizeAndPositionManager","_ref$maxScrollSize","maxScrollSize","chrome","webstore","_cellSizeAndPositionManager","_maxScrollSize","configure","getCellCount","getEstimatedCellSize","getLastMeasuredIndex","safeTotalSize","offsetPercentage","_getOffsetPercentage","round","_safeOffsetToOffset","getUpdatedOffsetForIndex","_offsetToSafeOffset","_ref4","getVisibleCellRange","resetCell","_ref5","_ref6","_ref7","createCallbackMemoizer","requireAllKeys","arguments","length","cachedIndices","callback","indices","keys","allInitialized","every","Array","isArray","indexChanged","some","cachedValue","join","updateScrollIndexHelper","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","sizeJustIncreasedFromZero","updateScrollIndexCallback","hasScrollToIndex","win","request","self","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","cancel","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","raf","caf","cancelAnimationTimeout","frame","SCROLL_POSITION_CHANGE_REASONS","Grid","_React$PureComponent","props","_this","__proto__","call","_onGridRenderedMemoizer","_onScrollMemoizer","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","_renderedColumnStartIndex","_renderedColumnStopIndex","_renderedRowStartIndex","_renderedRowStopIndex","_styleCache","_cellCache","_debounceScrollEndedCallback","_disablePointerEventsTimeoutId","setState","isScrolling","needToResetStyleCache","_invokeOnGridRenderedHelper","onSectionRendered","columnOverscanStartIndex","_columnStartIndex","columnOverscanStopIndex","_columnStopIndex","columnStartIndex","columnStopIndex","rowOverscanStartIndex","_rowStartIndex","rowOverscanStopIndex","_rowStopIndex","rowStartIndex","rowStopIndex","_setScrollingContainerRef","ref","_scrollingContainer","_onScroll","event","target","handleScrollEvent","columnSizeAndPositionManager","columnCount","_wrapSizeGetter","columnWidth","_getEstimatedColumnSize","rowSizeAndPositionManager","rowCount","rowHeight","_getEstimatedRowSize","state","instanceProps","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","prevScrollToColumn","scrollToColumn","prevScrollToRow","scrollToRow","scrollbarSize","scrollbarSizeMeasured","scrollDirectionHorizontal","scrollDirectionVertical","scrollLeft","scrollTop","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","_ref$alignment","alignment","_ref$columnIndex","columnIndex","_ref$rowIndex","rowIndex","offsetProps","_ref2$scrollLeft","scrollLeftParam","_ref2$scrollTop","scrollTopParam","_debounceScrollEnded","_props","autoHeight","autoWidth","totalRowsHeight","totalColumnsWidth","newState","_invokeOnScrollMemoizer","_props2","_ref4$columnIndex","_ref4$rowIndex","_props3","forceUpdate","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","_props4","getScrollbarSize","_handleInvalidatedGridSize","prevState","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_maybeCallOnScrollbarPresenceChange","prevProps","_this2","_props5","_state","columnOrRowCountJustIncreasedFromZero","_props6","autoContainerWidth","className","containerProps","containerRole","containerStyle","noContentRenderer","role","tabIndex","_state2","_isScrolling","gridStyle","boxSizing","direction","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","onScroll","maxWidth","maxHeight","pointerEvents","cellRenderer","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","visibleColumnIndices","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","delay","scrollingResetTimeInterval","Date","now","timeout","recomputeGridSize","_this3","_props7","clientHeight","scrollHeight","scrollWidth","Object","hasOwnProperty","Boolean","_onScrollbarPresenceChange","onScrollbarPresenceChange","horizontal","vertical","_ref8","_getScrollLeftForScrollToColumnStateUpdate","_getScrollTopForScrollToRowStateUpdate","nextProps","maybeStateA","maybeStateB","estimatedColumnSize","estimatedRowSize","_ref9","finalColumn","scrollBarSize","calculatedScrollLeft","finalRow","calculatedScrollTop","defaultProps","renderedCells","areOffsetsAdjusted","canCacheStyle","rowDatum","columnDatum","isVisible","left","cellRendererParams","renderedCell","push","propTypes","polyfill","defaultOverscanIndicesGetter"],"sourceRoot":""}